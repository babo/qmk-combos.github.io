{
  
  "1": {
    "title": "Chording Docs",
    "content": "What is a Chord? What is a Combo? . There is a fundamental difference between the two! A Combo is a native QMK feature and only applies to multi-key sequences and SEND_STRING(). However it can’t handle layering, processing strokes in chords and many other things required on smaller or heavily chorded keyboards! The Chording engine is the solution to this, but only has limited interoperability with QMK. . If you are only using Combos for augmenting a keymap, don’t use the chording engine, use the Combos! . Function Docs . If you have not read the Combo Docs, give those a quick browse. The format used for these chords is similar. Back? Awesome. . There are four functions that you can call in a dictionary, they are . PRES(chord, keyOut) : Send a single QMK keycode KEYS(chord, id, keys) : Send a sequence of keypresses SUBS(chord, id, string) : Send Strings and sequences SPEC(chord, func, arg) : Trigger Special functionality/QMK Interop . And you can use these to make any chorded dictionary! . Usage: . example.def (excerpts from en-keymap.def) . PRES(GA, KC_P) // Send P KEYS(GA|GO, cmb_9df323cdb026f7ce, {KC_LSFT, KC_9, COMBO_END}) // Send ( SUBS(GR|GI|GO|GP, str_E21E9A5405E9A529, &quot;pool &quot;) // &quot;pool &quot; SPEC(GA|GT|GN|GP, SPEC_STICKY, NUM) // Activate StickyBit for NUM . Notes: . – Only QMK Basic Keycodes can be sent using this engine. For shifted stuff you must use KEYS()! – ID can be set to whatever, however it must be unique. If it’s not the compiler will yell at you – For KEYS the brackets must be included, or the compiler will yell at you. . SPEC() . There’s a few special things that can be done through this code that changes how the engine operates. Heres a table of the currently implemented stuff . KeyCode Arg Function . SPEC_STICKY | Chord | This set’s/removes the specified bits from stickybits | . SPEC_REPEAT | none | Toggle the repeat mode until toggled off | . SPEC_CLICK | Keycode | Send the specified mousekey to the mouse subsytem. Requires mousekeys | . SPEC_SWITCH | QMK Layer | Turn on the given layer. The user is left to change back to the chorded layer | . Chords . A chord is just a bitmask made by or’ing together keys. These keys are defined in your ENGINE_CONFIG section. When the listed keys are pressed the action is run. The engine will match the longest chord possible! . The default engine mappings are below, if you’re doing a custom engine yours will be different. If you’re doing this on a normalish keyboard, just make a layout with the following keycode (using the function keys for your thumb keys! . QMK Keycode Chord Equivelent . KC_Q | GQ | . KC_W | GW | . KC_E | GE | . KC_R | GR | . KC_T | GT | . KC_Y | GY | . KC_U | GU | . KC_I | GI | . KC_O | GO | . KC_P | GP | . KC_A | GA | . KC_S | GS | . KC_D | GD | . KC_F | GF | . KC_G | GG | . KC_H | GH | . KC_J | GJ | . KC_K | GK | . KC_L | GL | . KC_SCLN | GCL | . KC_Z | GZ | . KC_X | GX | . KC_C | GC | . KC_V | GV | . KC_B | GB | . KC_N | GN | . KC_M | GM | . KC_COMM | GLT | . KC_DOT | GGT | . KC_SLSH | GQU | . KC_F1 | GL1 | . KC_F2 | GL2 | . KC_F3 | GL3 | . KC_F4 | GR3 | . KC_F5 | GR2 | . KC_F6 | GR1 | . Clear as mud? Good! Go take a look at some of the dictionaries, they’ll make more sense now :) . Custom Engines Managing Dicts .",
    "url": "http://localhost:4000/docs/chords/",
    "relUrl": "/docs/chords/"
  }
  ,"2": {
    "title": "Combo Docs",
    "content": "Parts of a Combo . Using this library with combos you have two functions avalible for use SUBS and COMB. They stand for Substitute and Combo respectfully. Lets take a look at a dictionary . germ-vim-helpers.def . COMB() . The COMB() Macro is responsible for take in a combo and outputting a single keypress!. The general form is COMB(ident, keycodeToEmit, keySequence...) So Line 3 in the above dictionary takes WE and outputs Escape. . Ident:A unique identifier, something descriptive works, but asdfffdsadf also works. . keycodeToEmit:A keycode from the QMK Keycode list. This includes Mouse, Shifted and Quantum keycodes. . keySequence: a series of keycodes to be pressed before triggering this output. . SUBS() . Subs is a very powerful macro and is used for all other sequences. For multicharacter, shifted or well anything else you’re going to use SUBS. At it’s core it relys on QMKs SEND_STRING() The general form is similar to COMBs, SUBS(ident, sendStringArg, keySequence...). So Line 10 outputs the start of the Interjection copypasta. . Ident:A unique identifier, something descriptive works, but asdfffdsadf also works. . sendStringArg: The macro or string to be send by SEND_STRING() . keySequence: a series of keycodes to be pressed before triggering this output. . Advanced SEND_STRINGing . The strings passed to SUBS() can be much more then dumb output! For sending control sequences, modifiers and other abritrary keycodes take a look at the QMK SEND_STRING docs. Just be aware that this library handles the hooking and storage, just pass the string to SUBS()! . Take a few minutes to play around and make a few of your own and add them to your combos.def! Next up, managing dictionaries. . Managing Dicts .",
    "url": "http://localhost:4000/docs/combos/",
    "relUrl": "/docs/combos/"
  }
  ,"3": {
    "title": "Custom Engine Config",
    "content": "Custom Engines . If you’re setting up a board for the first time (and not using the default config) here’s the dirty details for you. On the other hand if you’re just setting things up with the default engine config, skip along to . Managing Dicts . Sick you’re still around, time to get hacking away :) . So pop open keyboards/gboards/g/config_default.h that’s what we’re going to use as a reference here. The first thing you’ll notice is two defines C_SIZE and COMBO_MAX. . C_Size . This is the width of your chords in native AVR types. As of right now the engine supports up to 64 states. If you’re only using a board that uses 10 keys, you can probably squeeze it into a uint16. . Helpfully, if you have a STN() call of higher then C_SIZE, the compiler will get angry :) . COMBO_MAX . This is the Maximum number of keys that will be passed to KEYS(), for longer key combos this must be overridden to a value that can contain it. Note, this will be the default for ALL combos, so if you have one extra extra long combo it might be worth it to turn it into a SUBS() argument instead . STN . This is just a wrapper for setting the bit in your chord that gets toggled. Start your symbols at 0 and count up. You must end before you overflow C_SIZE! . COMMAND_MODE . This is the chord for toggling Command Mode, when this is stroked the keyboard starts buffering inputs when it’s stroked again the combo is sent. It’s useful for sending complex combos that would otherwise conflict with each other on smaller keyboards . ENGINE_CONFIG . This section is used by the engine to hook the QMK Keycodes and set the relevant Chord bits, it falls through to regular QMK processing if these aren’t hooked. You’ll need the ending is needed! . Overrideable Functions . Similar to stock QMK there are a handful of functions you can overide to change how the engine functions! Just define these in your keymap.c or in another file in your build. You should have a good understanding of this page from the QMK docs! . process_engine_post . C_SIZE process_engine_post(C_SIZE cur_chord, uint16_t keycode, keyrecord_t *record) . This is run after a key has been matched for the engine. You can use this to set additional bits in a chord or modify other keyboard things (Like LEDs!). If you just want to continue processing return cur_chord . process_engine_pre . C_SIZE process_engine_pre(C_SIZE cur_chord, uint16_t keycode, keyrecord_t *record) . This is run before any processing has happened. If you return false from here, normal QMK processing will happen instead of any engine things. Useful for keeping the engine from running when not on a specfic layer or for other uses. . process_chord_getnext . C_SIZE process_chord_getnext(C_SIZE cur_chord) . This is run in the event that a match could not be found. Normally the engine will try smaller and smaller bits of the chord until a match is found, but you can return the chord it should try next. Be careful though it’s easy to end up in infinate loops! Return 0 to continue with normal engine processing. . Hopefully that answers you hackery questions! Good luck on whacking this into your board and extending it! .",
    "url": "http://localhost:4000/docs/custom/",
    "relUrl": "/docs/custom/"
  }
  ,"4": {
    "title": "Dictionary List",
    "content": "Combo Dicts . Name Description Author Link . vim-helpers | Vim-focused combos for easy access to Esc/: and others | germ | view | . Chording Dicts . ASETNIOP Dicts . Name Description Author Link . cmd-keymap | Simple PC functions for aset | germ | view | . num-keymap | Numbers/Symbols Base | germ | view | . layer-keymap | Layer Switcher | germ | view | . en-colemak-keymap | English + Colemak support | germ | view | . en-dvorak-keymap | English + Dvorak support | germ | view | . da-keymap | Danish Language support | germ | view | . de-keymap | German Language support | germ | view | . en-keymap | English Support | germ | view | . es-keymap | Spanish Support | germ | view | . fn-keymap | Finnish Support | germ | view | . fr-keymap | French Support | germ | view | . hu-keymap | Hungarian Support | germ | view | . it-keymap | Italian Support | germ | view | . nl-keymap | Dutch Support | germ | view | . nw-keymap | Norwegian Support | germ | view | . pl-keymap | Polish Support | germ | view | . pt-keymap | Portuguese Support | germ | view | . ro-keymap | Romanian Support | germ | view | . sv-keymap | Swedish Support | germ | view | . tr-keymap | Turkish Support | germ | view | .",
    "url": "http://localhost:4000/docs/dicts/",
    "relUrl": "/docs/dicts/"
  }
  ,"5": {
    "title": "Home",
    "content": "Combos on Steroids, for your mechanical keyboard . Combos are a powerful feature, from Alt-Tab on the home row to your favourite snippets almost anything can be done with a programmable keyboard Here you’ll find a collection of user dictionaries, that can be easily layered into your own QMK keymaps taking your ergonomics to a whole new level. . Download some of the avalible dictionaries or start modifying your own! . Install Now View All Dicts . . Some user dictionaries . Name Description Author Link . vim-helpers | Vim-focused combos for easy access to Esc/: and others | germ | view | . Why? . Keyboards are too big and we need some serious ergonomic reform in our lives. The less keystrokes needed, the better. Look at 40%~ keyboards, small keyboards big utility :) .",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  ,"6": {
    "title": "Installation Guide",
    "content": "Install . Lets get this party started, you’ll need a QMK Powered Keyboard, a working QMK build environment. and your own keymap. Once you have those set up, come on back. If you’re using a newer g Heavy Inudstries/ board these may be enabled already! . . Combos . Still here? Awesome. Let’s edit your setup. Pop open your keymaps rules.mk and add this somewhere. If there isn’t a rules.mk file in your keymap, create it! . VPATH += keyboards/gboards/ COMBO_ENABLE=yes . This line lets the compiler know where to look for combos. Now make a empty file named combos.def in your keymap directory. . Add this to your config.h in your keymap directory. It’s optional, but helps with errors from typing too fast! #define COMBO_TERM 50 . Your first combo . In combos.def add this statement. SUBS(helloWorld, &quot;QMK is pretty rad eh?&quot;, KC_H, KC_J) . Save it, compile your keymap and flash it. If you’ve done it correctly pressing H and J at the same time will output the text. Congrats! . If you’re not enabling the Chording Engine, head on over to . Creating Combos . Chording . If you wish to use the onboard chording engine, a little bit more tweaking needs to be done. The easy way is to grab a preconfigured board, but in lieu of that, there’s a default config that is tuned for QWERTY, you can use this as a base it’s over in gboards/g/config_default.h, copy this to your keymap folder as config_engine.h . You’ll need to edit rules.mk as follows: . VPATH += keyboards/gboards/ SRC += g/engine.c . Make a file called dicts.def and add this statement: SUBS(GD | GF, undef1, &quot;Oh yeah, it&#39;s all coming together.&quot;) . If you’ve done everything correctly, your firmware should compile and output that string when DF is pressed! Head on over to the next section for how to import existing dictionaries and whatnot . Creating Chords .",
    "url": "http://localhost:4000/docs/install/",
    "relUrl": "/docs/install/"
  }
  ,"7": {
    "title": "Managing Dictionaries",
    "content": "Managing dictionaries . Now for the fun part! Managing (and most likely creating) dictionaries. There are two main types of dictionaries: Combo dictionaries (combos.def) and Chording dictionaries (dicts.def) . If you’re here off the begining, there’s going to be more creating dictionries than just importing them. Be sure to PR your dictionaries against qmk-combos/combos any PRs are appriciated! . combos.def . Let’s start with an example . #include &quot;combos/germ-vim-helpers.def&quot; // Important for work! #include &quot;combos/germ-mouse-keys.def&quot; //#include &quot;mycombos.def&quot; . Seems pretty straight forward eh? This is just C code that gets embedded. So you can do // or /* */ style comments. The dictionaries will be templated in. To add new ones just add a #include statement, to remove them either delete the line or prefix it with // . dicts.def . Example: . #include &quot;dicts/aset/en-keymap.def&quot; #include &quot;dicts/aset/cmd-keymap.def&quot; #include &quot;dicts/aset/num-keymap.def&quot; #include &quot;dicts/aset/layer-keymap.def&quot; #include &quot;user.def&quot; . The format is exactly the same as combos.def, but should only be loaded with chorded dictionaries In this example if we wanted to change the ASETNIOP language we would just change the first include to something like de-keymap.def einfach! . Prefixes . Some dictionaries support a special variable PREFIX, this can be optionally defined before including a .def. The prefix will be added to any included definitions. Here’s an example for how to use these: . NOTE: You must include the trailing ‘|’ or ‘,’ and remember to #undef it after . combos.def: . #define PREFIX KC_Z, #include &quot;combos/germ-mouse-keys.def&quot; #undef PREFIX . dicts.def: . #define PREFIX GZ | #include &quot;combos/germ-mouse-keys.def&quot; #undef PREFIX . Best Practices . Keep defs small and constrained to a context (Mouse keys, Text shorthands, Firefox-Shortcuts, etc…) | Remember .defs can include other .defs, break it up! | Use PREFIX where it makes sense! If all of your movements are using KC_S, change it to prefix! | A blank prefix can be done with “#define PREFIX “ and omitting the last argument | Submit them back (we don’t bite!) | . Using PREFIX in a .def . Because a user may override this, provide a blank or sensible default. You can do this as such. In addition the | or , is ommitted from the definition. Combos: . #ifndef PREFIX #define PREFIX #endif COMB(str10, KC_ESC, PREFIX KC_W, KC_E) ... . Chords: . #ifndef PREFIX #define PREFIX GS | #endif SUBS(PREFIX GA, str10, &quot;How to use a prefix!&quot;) ... .",
    "url": "http://localhost:4000/docs/manage/",
    "relUrl": "/docs/manage/"
  }
  
}